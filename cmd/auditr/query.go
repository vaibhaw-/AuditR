package main

import (
	"fmt"
	"strings"
	"time"

	"github.com/spf13/cobra"

	"github.com/vaibhaw-/AuditR/internal/auditr/query"
)

// This file implements the CLI command for the AuditR query phase.
// It provides a command-line interface for filtering and summarizing audit logs.
// The command supports various filtering options and can process multiple input files.

// CLI flag variables for the query command
// These are populated by Cobra and passed to the query package
var (
	queryFlagInput         []string // Input NDJSON file(s) - supports multiple files
	queryFlagOutput        string   // Output file path - empty means stdout
	queryFlagSensitivity   []string // Sensitivity categories to filter (PII, PHI, Financial)
	queryFlagUser          string   // Database user to filter by
	queryFlagIP            string   // Client IP address to filter by
	queryFlagTypes         []string // Query types to filter (SELECT, INSERT, UPDATE, etc.)
	queryFlagBulk          bool     // Filter for bulk operations only
	queryFlagBulkType      string   // Filter by specific bulk operation type (export, import, etc.)
	queryFlagFilter        []string // Field names to filter in sensitivity entries
	queryFlagSince         string   // Absolute time filter (ISO 8601 UTC)
	queryFlagLast          string   // Relative time filter (7d, 24h, etc.)
	queryFlagExcludeErrors bool     // Exclude ERROR events from results
	queryFlagSummary       bool     // Print summary statistics instead of events
	queryFlagLimit         int      // Limit number of output events
)

// queryCmd is the Cobra command definition for the query phase
var queryCmd = &cobra.Command{
	Use:   "query",
	Short: "Filter and summarize enriched or hashed audit logs",
	Long: `Query allows auditors and developers to filter and summarize enriched or hashed audit logs in NDJSON format.
It is designed for local analysis, compliance verification, and lightweight data reduction.

The command reads one or more NDJSON files generated by earlier AuditR phases (enrich, verify) and applies filters on structured metadata fields.
It outputs matching events or summary counts in NDJSON format.

Examples:
  # All PII-related events from last 7 days
  auditr query --input ./out/enriched_pg.ndjson --sensitivity PII --last 7d

  # Filter all bulk operations by appuser3
  auditr query --input ./out/*.ndjson --user appuser3 --bulk

  # Filter only export operations
  auditr query --input ./out/*.ndjson --bulk-type export

  # Filter events touching 'email' or 'card_last4' fields
  auditr query --input ./out/enriched_pg.ndjson --filter email,card_last4

  # Summary of PII and PHI queries
  auditr query --input ./out/enriched_pg.ndjson --sensitivity PII,PHI --summary`,
	RunE: runQuery, // Main execution function
}

// init sets up the command flags and adds it to the root command
func init() {
	// Input/Output flags
	queryCmd.Flags().StringSliceVar(&queryFlagInput, "input", []string{}, "Input NDJSON file(s). Multiple files separated by space (shell glob expansion supported). Default: stdin")
	queryCmd.Flags().StringVar(&queryFlagOutput, "output", "", "Output NDJSON file path. Default: stdout")

	// Sensitivity filtering flags
	queryCmd.Flags().StringSliceVar(&queryFlagSensitivity, "sensitivity", []string{}, "Filter by sensitivity categories (e.g., PII, PHI, Financial). Case-insensitive")
	queryCmd.Flags().StringSliceVar(&queryFlagFilter, "filter", []string{}, "Comma-separated field names to match in sensitivity array entries (e.g., email, ssn)")

	// User and connection filtering flags
	queryCmd.Flags().StringVar(&queryFlagUser, "user", "", "Filter by database user (db_user field)")
	queryCmd.Flags().StringVar(&queryFlagIP, "ip", "", "Filter by client IP address (client_ip field, if present)")

	// Query type and operation filtering flags
	queryCmd.Flags().StringSliceVar(&queryFlagTypes, "type", []string{}, "Filter by canonical query type (SELECT, INSERT, UPDATE, DELETE, etc.)")
	queryCmd.Flags().BoolVar(&queryFlagBulk, "bulk", false, "Show only bulk operations (bulk == true)")
	queryCmd.Flags().StringVar(&queryFlagBulkType, "bulk-type", "", "Filter by specific bulk operation type (export, import, backup, etc.)")

	// Time-based filtering flags
	queryCmd.Flags().StringVar(&queryFlagSince, "since", "", "Include events on or after the given time (ISO 8601 UTC)")
	queryCmd.Flags().StringVar(&queryFlagLast, "last", "", "Include events from the last N days/hours (e.g., 7d, 24h). Supports d and h units")

	// Error handling and output flags
	queryCmd.Flags().BoolVar(&queryFlagExcludeErrors, "exclude-errors", false, "Exclude events with query_type == \"ERROR\" from results")
	queryCmd.Flags().BoolVar(&queryFlagSummary, "summary", false, "Print summary counts instead of full events")
	queryCmd.Flags().IntVar(&queryFlagLimit, "limit", 0, "Limit number of output events")

	// Add to root command
	rootCmd.AddCommand(queryCmd)
}

// runQuery is the main execution function for the query command.
// It parses CLI flags, validates input, and delegates to the query package.
//
// Processing steps:
// 1. Parse comma-separated flags (--sensitivity, --type, --filter)
// 2. Parse time filters (--since, --last) with validation
// 3. Validate conflicting options (--since vs --last)
// 4. Build QueryOptions struct
// 5. Delegate to query.RunQuery()
//
// Error handling:
// - Invalid time formats return descriptive errors
// - Conflicting options are caught and reported
// - All errors are wrapped with context
func runQuery(cmd *cobra.Command, args []string) error {
	// Parse comma-separated flags into individual values
	// This handles flags like --sensitivity "PII,PHI" -> ["PII", "PHI"]
	queryFlagSensitivity = parseCommaSeparated(queryFlagSensitivity)
	queryFlagTypes = parseCommaSeparated(queryFlagTypes)
	queryFlagFilter = parseCommaSeparated(queryFlagFilter)

	// Parse time filters with proper validation
	var since time.Time
	var lastDuration time.Duration
	var err error

	// Parse --since flag (absolute time)
	if queryFlagSince != "" {
		since, err = time.Parse(time.RFC3339, queryFlagSince)
		if err != nil {
			return fmt.Errorf("invalid --since format, expected RFC3339 (e.g., 2025-10-01T00:00:00Z): %w", err)
		}
	}

	// Parse --last flag (relative time)
	if queryFlagLast != "" {
		lastDuration, err = query.ParseDuration(queryFlagLast)
		if err != nil {
			return fmt.Errorf("invalid --last format, expected duration like 7d or 24h: %w", err)
		}
	}

	// Validate that both --since and --last are not provided
	// This prevents confusion about which time filter takes precedence
	if !since.IsZero() && lastDuration > 0 {
		return fmt.Errorf("cannot specify both --since and --last; --last takes precedence")
	}

	// Build QueryOptions struct from parsed flags
	opts := query.QueryOptions{
		InputFiles:    queryFlagInput,
		OutputFile:    queryFlagOutput,
		Sensitivity:   queryFlagSensitivity,
		User:          queryFlagUser,
		IP:            queryFlagIP,
		Types:         queryFlagTypes,
		Bulk:          queryFlagBulk,
		BulkType:      queryFlagBulkType,
		FilterFields:  queryFlagFilter,
		Since:         since,
		LastDuration:  lastDuration,
		ExcludeErrors: queryFlagExcludeErrors,
		Summary:       queryFlagSummary,
		Limit:         queryFlagLimit,
	}

	// Delegate to the query package for actual processing
	return query.RunQuery(opts)
}

// parseCommaSeparated parses comma-separated values from a string slice.
// This function handles flags that accept multiple values separated by commas.
//
// Examples:
// - ["PII,PHI"] -> ["PII", "PHI"]
// - ["SELECT,INSERT", "UPDATE"] -> ["SELECT", "INSERT", "UPDATE"]
// - ["PII", "PHI,Financial"] -> ["PII", "PHI", "Financial"]
//
// The function trims whitespace and filters out empty values.
func parseCommaSeparated(values []string) []string {
	var result []string
	for _, value := range values {
		parts := strings.Split(value, ",")
		for _, part := range parts {
			trimmed := strings.TrimSpace(part)
			if trimmed != "" {
				result = append(result, trimmed)
			}
		}
	}
	return result
}
